import fs from 'fs';
import path from 'path';
import { config } from 'dotenv';
import type {
  Quiz,
  CloudflareAIResponse,
  CloudflareAIRequest,
} from './types.js';
import { parseJson, parseJsonWithFallback } from './jsonParser.js';
import { SYSTEM_PROMPT, buildQuizPrompt } from './prompts.js';

// Load .env file
config();

const readmePath = path.join(process.cwd(), 'README.md');

const getKstDateId = (): string => {
  const now = new Date();
  const kst = new Date(now.getTime() + 9 * 60 * 60 * 1000);
  const yyyy = String(kst.getUTCFullYear());
  const mm = String(kst.getUTCMonth() + 1).padStart(2, '0');
  const dd = String(kst.getUTCDate()).padStart(2, '0');
  return `${yyyy}${mm}${dd}`;
};

const CF_ACCOUNT_ID = process.env.CF_ACCOUNT_ID;
const CF_API_TOKEN = process.env.CF_API_TOKEN;
const CF_MODEL = process.env.CF_MODEL || '@cf/meta/llama-3.2-3b-instruct';

const validateGeneratedQuiz = (quiz: Partial<Quiz>): quiz is Quiz => {
  if (
    typeof quiz.question !== 'string' ||
    quiz.question.length < 5 ||
    typeof quiz.answer !== 'string' ||
    quiz.answer.length < 5
  ) {
    return false;
  }

  (quiz as Quiz).id = getKstDateId();
  return true;
};

const generateQuizWithCloudflareAI = async (): Promise<Quiz | null> => {
  try {
    if (!CF_ACCOUNT_ID || !CF_API_TOKEN) {
      throw new Error(
        'CF_ACCOUNT_ID and CF_API_TOKEN environment variables are required'
      );
    }

    const topics = ['JavaScript', 'Web', 'HTTP', 'CSS', 'Node.js', 'CS Basics'];
    const topicOfTheDay = topics[new Date().getUTCDay() % topics.length];

    const resp = await fetch(
      `https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/ai/run/${CF_MODEL}`,
      {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${CF_API_TOKEN}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: [
            { role: 'system', content: SYSTEM_PROMPT },
            { role: 'user', content: buildQuizPrompt(topicOfTheDay) },
          ],
          max_tokens: 1000,
          temperature: 0.7,
        } as CloudflareAIRequest),
      }
    );

    if (!resp.ok) {
      const errorText = await resp.text();
      throw new Error(`Cloudflare AI error: ${resp.status} - ${errorText}`);
    }

    const result = (await resp.json()) as CloudflareAIResponse;
    let parsed: Quiz;
    try {
      parsed = parseJson<Quiz>(result.result.response);
    } catch {
      parsed = parseJsonWithFallback<Quiz>(result.result.response);
    }

    if (!validateGeneratedQuiz(parsed)) {
      console.error('Validation failed for quiz:', parsed);
      return null;
    }

    return parsed;
  } catch (e) {
    const error = e as Error;
    console.error('Cloudflare AI generation failed:', error.message);
    return null;
  }
};

const quiz = await generateQuizWithCloudflareAI();
if (!quiz) {
  console.error('No quiz generated by Cloudflare AI. Aborting.');
  process.exit(1);
}

// Format difficulty badge with emoji
const difficultyEmoji: Record<string, string> = {
  beginner: 'üü¢',
  intermediate: 'üü°',
  advanced: 'üî¥',
};
const difficultyBadge = quiz.difficulty
  ? `${difficultyEmoji[quiz.difficulty] || 'üìå'} **${quiz.difficulty}**`
  : '';

// Format tags as badges
const tagsBadge = quiz.tags?.length
  ? `üè∑Ô∏è ${quiz.tags.map((tag) => `\`${tag}\``).join(' ')}`
  : '';

// Format date
const dateBadge = `üìÖ ${getKstDateId()}`;

// Format answer with better structure
const formatAnswer = (answer: string): string => {
  // If answer contains code blocks, preserve them
  if (answer.includes('```')) {
    return answer;
  }

  const lines = answer
    .split('\n')
    .map((line) => line.trim())
    .filter(Boolean);

  // Format as blockquote with proper spacing
  return lines.map((line) => `> ${line}`).join('\n\n');
};

const newQuizSection = `<!--START_SECTION:quiz-->

<div align="center">

### ‚ùì ${quiz.question}

</div>

<div align="center">

${[difficultyBadge, tagsBadge, dateBadge].filter(Boolean).join(' ‚Ä¢ ')}

</div>

---

<details>
<summary><b>üí° Show Answer</b></summary>

<br>

${formatAnswer(quiz.answer)}

<br>

</details>

<!--END_SECTION:quiz-->`;

const readme = fs.readFileSync(readmePath, 'utf-8');
fs.writeFileSync(
  readmePath,
  readme.replace(
    /<!--START_SECTION:quiz-->[\s\S]*<!--END_SECTION:quiz-->/,
    newQuizSection
  )
);

console.log(`Updated quiz: ${quiz.question}`);
