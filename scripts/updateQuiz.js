import fs from "fs";
import path from "path";

const readmePath = path.join(process.cwd(), "README.md");

const getKstDateId = () => {
  const now = new Date();
  const kst = new Date(now.getTime() + 9 * 60 * 60 * 1000);
  const yyyy = String(kst.getUTCFullYear());
  const mm = String(kst.getUTCMonth() + 1).padStart(2, "0");
  const dd = String(kst.getUTCDate()).padStart(2, "0");
  return `${yyyy}${mm}${dd}`;
};

const CF_ACCOUNT_ID = process.env.CF_ACCOUNT_ID;
const CF_API_TOKEN = process.env.CF_API_TOKEN;
const CF_MODEL = process.env.CF_MODEL || "@cf/meta/llama-3.2-3b-instruct";

const buildPrompt = (topicOfTheDay) => {
  return `Generate exactly ONE development quiz about ${topicOfTheDay}.

CRITICAL: Respond with ONLY valid JSON. No markdown, no code blocks, no explanations. Just the raw JSON object.

Requirements:
- Language: English
- Question: 1-2 sentences
- Answer: 3-6 lines, in Markdown format (use code fences when helpful)
- Difficulty: beginner, intermediate, or advanced
- Type: "open" or "mcq"
- Tags: array of relevant tags

JSON schema (respond with ONLY this structure, no other text):
{
  "id": "YYYYMMDD",
  "question": "Your question here",
  "answer": "Your answer in Markdown",
  "difficulty": "beginner|intermediate|advanced",
  "tags": ["tag1", "tag2"],
  "type": "open|mcq"
}`;
};

const validateGeneratedQuiz = (q) => {
  if (!q || typeof q !== "object") return false;
  if (typeof q.question !== "string" || q.question.length < 5) return false;
  if (typeof q.answer !== "string" || q.answer.length < 5) return false;
  
  q.id = getKstDateId();
  return true;
};

const generateQuizWithCloudflareAI = async () => {
  try {
    if (!CF_ACCOUNT_ID || !CF_API_TOKEN) {
      throw new Error("CF_ACCOUNT_ID and CF_API_TOKEN environment variables are required");
    }

    const topics = ["JavaScript", "Web", "HTTP", "CSS", "Node.js", "CS Basics"];
    const topicOfTheDay = topics[new Date().getUTCDay() % topics.length];
    
    const apiUrl = `https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/ai/run/${CF_MODEL}`;
    
    const resp = await fetch(apiUrl, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${CF_API_TOKEN}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        messages: [
          {
            role: "system",
            content: "You are a helpful assistant that generates development quiz questions. CRITICAL: You must respond with ONLY valid JSON, no explanations, no code blocks, no markdown formatting. Just the raw JSON object."
          },
          {
            role: "user",
            content: buildPrompt(topicOfTheDay)
          }
        ],
        max_tokens: 1000,
        temperature: 0.7,
      }),
    });

    if (!resp.ok) {
      const errorText = await resp.text();
      throw new Error(`Cloudflare AI error: ${resp.status} - ${errorText}`);
    }

    const result = await resp.json();

    const content = result?.result?.response;
    
    if (!content) {
      console.error("Unexpected response format:", JSON.stringify(result, null, 2));
      throw new Error("No content from Cloudflare AI. Check response structure above.");
    }

    let jsonString = content.trim();
    
    jsonString = jsonString.replace(/^```(?:json)?\s*/m, "").replace(/\s*```$/m, "");
    
    const jsonMatch = jsonString.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      jsonString = jsonMatch[0];
    }
    
    jsonString = jsonString.trim();
    
    let parsed;
    try {
      parsed = JSON.parse(jsonString);
    } catch (e) {
      console.error("JSON parsing failed. Original content:");
      console.error("---");
      console.error(content.substring(0, 500));
      console.error("---");
      console.error("Attempted JSON:");
      console.error("---");
      console.error(jsonString.substring(0, 500));
      console.error("---");
      console.error("Error:", e.message);
      
      const deepMatch = jsonString.match(/\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}/);
      if (deepMatch) {
        try {
          parsed = JSON.parse(deepMatch[0]);
        } catch (e2) {
          throw new Error(`JSON ÌååÏã± Ïã§Ìå®: ${e.message}. Ïû¨ÏãúÎèÑÎèÑ Ïã§Ìå®: ${e2.message}`);
        }
      } else {
        throw new Error(`JSON ÌååÏã± Ïã§Ìå®: ${e.message}. JSON Í∞ùÏ≤¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`);
      }
    }

    if (!validateGeneratedQuiz(parsed)) {
      console.error("Validation failed for quiz:", parsed);
      return null;
    }
    
    return parsed;
  } catch (e) {
    console.error("Cloudflare AI generation failed:", e.message);
    return null;
  }
};

const quizData = await generateQuizWithCloudflareAI();
if (!quizData) {
  console.error("No quiz generated by Cloudflare AI. Aborting.");
  process.exit(1);
}
const quiz = quizData;

let readme = fs.readFileSync(readmePath, "utf-8");

const metaParts = [];
if (quiz.difficulty) metaParts.push(`Difficulty: ${quiz.difficulty}`);
if (Array.isArray(quiz.tags) && quiz.tags.length) metaParts.push(`Tags: ${quiz.tags.join(", ")}`);
metaParts.push(`Date: ${getKstDateId()}`);
const metaBlock = metaParts.length ? `_${metaParts.join(" | ")}_\n\n` : "";

const newQuizSection = `<!--START_SECTION:quiz-->

**‚ùì Q. ${quiz.question}**

${metaBlock}<details>
<summary>Show Answer üëÄ</summary>

${quiz.answer}

</details>
<!--END_SECTION:quiz-->`;

readme = readme.replace(
  /<!--START_SECTION:quiz-->[\s\S]*<!--END_SECTION:quiz-->/,
  newQuizSection,
);

fs.writeFileSync(readmePath, readme);

console.log(`Updated quiz: ${quiz.question}`);
